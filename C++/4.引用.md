[TOC]



### 引用（reference）

对一个数据可以建立一个“引用”，它的作用是为一个变量起一个别名。

##### 引用的特点

- 声明变量b为“引用”，并不需要另外开辟内存单元来存放b值，使变量b具有变量a的地址；
- 引用不是一种独立的数据类型。对引用只有声明，没有定义；
- 声明一个引用时，必须同时使之初始化，即声明它代表哪一个变量；
- 在声明一个引用后，不能再使之作为另一个变量的引用；

```c++
int a;
int &b = a;  //b是a的引用

// Wrong cases
int &b2 = b; 	//Wrong,不能建立引用的引用 

int c[5];
int &d2 = c  	//Wrong, 不能建立数组引用
int &d = c[0];	//Wrong, 不能建立数组元素的别名
```



##### 引用的底层实现

引用实际上存放的是被引用变量的地址，所以它的内存大小是指针的大小。但是引用和指针是不一样的，别混淆。

```c++
int a = 1;
int &b = a;

cout << b;  //输出为1，相当于 *b
cout << &b;   //输出的是a变量的地址，相当于 &(*b)
```

> 引用和指针的实现方式相同，但是在编译时是被区别对待～引用不允许改变引用对象；不允许被寻址；又因为实际上是存放指针，所以需要被初始化。

> C++中引用的底层实现原理详解：https://blog.csdn.net/lws123253/article/details/80353197





##### 引用作为函数参数

三种函数参数传递的方法：

- **将变量名作为实参和形参。**这时传给形参的是变量的值，传递是单向的。如果在执行函数期间，形参的值发生变化，并不传回给实参。因为在调用函数时，形参和实参不是同一个存储单元；
- **传递变量的地址。**形参是指针变量，实参是一个变量的地址，调用函数时，形参得到实参的地址，因此指向实参变量单元；
- **以引用作为形参**。*在“虚实结合”时建立变量的引用*，使形参名作为实参的“引用”，即形参成为实参的引用。

```c++
//变量名作为实参和形参
void swap(int x, int y){;}
...
int a = 1, b = 2;
swap(a, b);

//传递变量的地址
void swap(int* x, int* y){;}
...
int a = 1, b = 2;
swap(&a, &b);

//以引用作为形参
void swap(int& x, int& y){;}
...
int a = 1, b = 2;
swap(a, b);   //实参传递给形参时，因为形参定义是引用，所以会传递a和b的地址
```



**第三种传递方式和前两种的区别：**前两种传递的实参的值（变量的值或者地址），所以需要对形参分配存储单元（引用实现的时候不也要分配内存空间？）。而第三种中，形参x和y分别为实参a和b的引用，x和y获得的分别是a和b的地址。

