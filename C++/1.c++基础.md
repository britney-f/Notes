### C++执行过程

① 编译：把.cpp文件编译为.obj/.o为后缀的文件，编译的作用是对源程序进行词法检查和语法检查。

② 连接：用系统提供的“连接程序（linker）”将一个程序的所有目标程序和系统的库文件以及系统提供的其他信息连接起来，最终形成一个可执行的二进制文件（例如.exe结尾的文件）。

③ 运行：运行最终形成的可执行二进制文件。



### 基本数据类型所占字节数

|          数据类型          | 字节数 32位(64位) |
| :------------------------: | :---------------: |
|            char            |         1         |
|           char*            |       4 (8)       |
|  (signed / unsigned) int   |         4         |
| (signed / unsigned ) short |         2         |
|  (signed / unsigned )long  |       4 (8)       |
|         long long          |         8         |
|           float            |         4         |
|           double           |         8         |

> 32位的寻址空间是2^32，即32个bit，也就是4个字节，所以在64位编译器中char*为8位。



混合计算时各类数值型数据之间的转换：

![表达式中各类数值型数据间的混合运算 的图像结果](https://tse2-mm.cn.bing.net/th?id=OIP.WJv6wgkdfqLo31l9TYxC_QAAAA&w=193&h=179&c=7&o=5&pid=1.7)

> 两个float型数据相加，也都先转换成double型，然后再相加。



### ASCII码表

**顺序**：数字 --> 大写字母 --> 小写字母

`‘\0ddd’` 表示八进制数 `0ddd` 对应的ASCII字符

`'\0xhh'` 表示16进制 `0xhh` 对应的ASCII字符



### 常量

- 数值常量

  - 整型常量
  - 浮点数

- 字符常量

  - 普通字符常量：字符数据存放在内存单元时，是将该字符对应的ASCII代码放到存储单元中。
  - 转义字符常量

- 字符串常量

- 符号常量     

   `#define PRICE 30`  ：指定PRICE 在本程序单位中代表常量30
   
- 逻辑常量：`false` 和 `true` ，在内存中占1个字节，用来存放0或1。



### 变量

**定义：**为变量分配存储空间，还可为变量指定初始值。一个程序中，变量只能被定义一次。

**声明：**向程序表明变量的类型和名字，不分配存储空间，例如 `extern int a; ` ，声明可以多次。

> 变量的定义也是声明。

**初始化：**大部分变量的初始化是在程序运行时执行本函数时赋予初值的。

> 静态存储变量和外部变量的初始化是在编译阶段完成的。





### 常变量(constant variable)

- 在定义变量是加上关键字const，则变量的值在程序运行期间不能改变。

- 和 `#define` 定义的符号常量的区别：

  **符号常量**是用一个符号代替一个常量，在预编译时把所有符号常量替换为指定的常量，它没有类型，在内存中不存在以符号常量命名的存储单元。

  **常变量**具有变量的特征，具有类型，在内存中存在以它命名的存储单元，可以用 `sizeof` 运算符计算它的长度。

  用 `#define` 定义符号常量是C语言采用的方法。





### 输入输出

在C语言中，输入和输出的功能是通过调用 `scanf` 函数和 `printf` 函数来实现的，在C++中是通过调用输入输出流库中的流对象 `cin` 和 `cout` 实现的。

##### 1. `cin` 和 `cout` 

```c++
cin >> a >> b;
cout << a << '+' << b << endl;
```

- C++的输出和输入是用“流（stream）”的方式实现的。“流”指的是来自设备或传给设备的一个数据流。数据流是由一系列字节组成的。
-  `cout` 是输出流对象的名字， `cin` 是输入流对象的名字。
- 在定义流对象时，系统会在内存中开辟一段缓冲区，用来暂存输入输出流的数据。在执行 `cout` 语句时，并不是插入一个数据就马上输出一个数据，而是先把插入的数据顺序存放在输出缓冲区中，直到输出缓冲区满或遇到 `cout` 语句中的 `endl` （或 `'\n'`,  `ends`, `flush`）为止，此时将缓冲区中已有的数据一起输出，并清空缓冲区。
-  `cout` 和`cin` 都会自动进行数据类型转换或者提取相应长度的字节，注意，**`cin` 语句不能把空格字符和回车换行符作为字符输入给字符变量**。



##### 2. `scanf` 和 `printf` 

```c++
scanf("%d %c %f", &a, &b, &c);
printf("a=%d, b=%c, c=%f\n", a, b, c);
```





### 关系运算符的等级

![img](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=59a3e1017d3e6709aa0d4dad5aaef458/63d9f2d3572c11df57c9a205612762d0f703c2f8.jpg)

> **！逻辑运算符 > 算术运算符 > 关系运算符 > &&和||逻辑运算符 > 赋值运算符**





### 函数

##### 1. 形式参数和实际参数

- **形式参数**是定义函数时函数后面括号中的变量名；
- **实际参数**是调用函数时，函数名后面口号中的参数；
- 在定义函数时指定的形参，在未出现函数调用时，它们并不占内存中的存储单元，因此它们是形式参数或虚拟参数，表示它们并不是实际存在的数据，只有在发生函数调用时，形参才被分配内存单元，以便接受从实参传来的数据；
- 参变量对形参变量的数据传递是“值传递”， 即单向传递，形参的值发生改变并不会影响主调函数中实参的值；



##### 2. 函数的返回值

如果函数的类型和return语句中的表达式的值不一致，则以函数类型为准。



##### 3. 函数声明

```c++
float add(float x, float y);
// float add (float, float); //函数原型（function prototype）
```



##### 4. 函数定义

```c++
float add(float x, float y){
	return x + y;
}
```



##### 5. 函数调用

```c++
sum = add(float x, float y);
```



##### 6. 内联函数

函数的频繁调用会降低程序的执行效率，所以C++提供一种高效的方法，即在编译时将所调用函数的代码直接嵌入到主调函数中，而不是讲流程转出去，这种嵌入到主调函数中的函数称为**内联函数（inline function）**。

```c++
inline int add(float x, float y); //声明
//定义
//如果声明中有inline，则定义中的inline可有可无
inline int add(float x, float y){
	return x + y;
}
```

> 在编译系统遇到函数调用 `add(a, b)` 时，就用 `add` 函数体的代码代替 `add(a, b)` 
>
> 内联函数中不能包括复杂的控制语句，如循环语句和 `switch` 语句。



##### 7. **函数重载（function overloading）**

用一个函数名定义多个函数，这些函数的参数个数、参数类型或参数顺序中至少有一个不相同。

```c++
int max(int a, int b, int c);
float max(float a, float b);
```



##### 8. 函数模板（function template）

函数模板是一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。

```c++
template <typename T> //模板声明，其中T为参数类型
// or template <class T>
T add(T a, T b, T c){
	return a + b + c;
}

max(1, 2, 2);
max(1.2, 2.1, 3.0);
```

> 调用函数时，系统会根据实参的类型来取代模板中的虚拟类型。

**适用范围：**函数体相同、函数的参数个数相同而类型不同的情况。



##### 9. 有默认参数的函数

最好在函数调用前指定好默认值，可以是函数声明或定义中。但不要声明和定义中同时指定默认值，编译时可能会报错；如果不报错，编译器使用的是先遇到的默认值。





### 局部变量的全局变量

##### 1. 内存的分配

- **动态存储区**包括堆（heap）和栈（stack）。
  - **栈（stack）**由编译器自动分配释放管理，其中包括，局部变量、函数调用时的现场保护和返回地址等
  - **堆（heap）**由程序员分配释放管理，例如用 `malloc` ， `new` 等分配内存
- **静态存储区**用来存放全局变量和静态变量，它被划分为未初始化的数据段（又称bss，block started by symbol）和初始化的数据段。
- **正文段**：又称代码段，存储可执行文件的指令。

![img](https://images0.cnblogs.com/blog/427267/201310/21113258-16bba106aacb4b998f2d5f52a5aa603a.jpg)****



**2. static声明静态局部变量**

- 函数中的局部变量的值在函数调用结束后不消失而保留原值，即其占用的存储单元不释放，**在下一次该函数调用时，该变量保留上一次函数调用结束时的值**。
- 静态局部变量如果没有被初始化，在编译时自动赋初值0（对数值型变量）或空字符（对字符变量）
- 虽然静态局部变量在函数调用结束后仍然存在，但其他函数是不能引用它的。



##### 3. 寄存器变量

当变量使用频繁时，可以将局部变量放到寄存器中，提高执行效率。

```c++
register int i = 1;
```



##### 4. extern声明外部变量

`extern` 声明外部变量，允许它在其余文件中也可以使用。extern 只用来声明已经定义的外部变量，而不能用于变量的定义。

```c++
A.cpp
//包含B.cpp和C.cpp
extern int a;

int main(){
	cout << a;
}

B.cpp
int a=5;

c.cpp
int a = 10;

//上诉代码会出现什么问题？
//因为多次定义a变量，所以会出现连接错误。
```



##### 5. static声明静态外部变量

`static` 声明全局变量，可以将变量限于被本文件引用，而不能被其他文件引用。



##### `static` 关键字的作用

- 隐藏
  - **修饰全局变量或函数**，同时编译多个文件时，未加 `static` 前缀的全局变量和函数可以被其他源文件访问，加了 `static` 后对当前文件可见。
  - **修饰局部变量**，使得局部变量在调用结束之前不消失而保留值，但是对其他函数不可见（和上一个特征很像）
- **修饰成员变量**，该变量变成静态成员变量，它不属于对象，而属于类，类的所有对象只有一份拷贝；不能在类的内部初始化，类内只能声明，定义需要在类外；类外定义时不需要 `static` 关键字，只需要表明作用域。
- **修饰成员函数**，该函数变成静态成员函数，它不属于对象，而属于类；形参不会生成 `this` 指针，所以仅能访问静态数据和静态成员函数；调用不依赖对象，所以不能作为虚函数，只能用类的作用域调用。



### 头文件

头文件中包括：对类型的声明、函数声明、内置（inline）函数的定义、宏定义、全局变量定义、外部变量声明和其他头文件。

由于有 `#include` 指令，就可以把不同的文件组合在一起，形成一个文件。因此说，头文件是源文件之间的接口。

