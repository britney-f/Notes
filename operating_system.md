#### 什么是操作系统

多数计算机有两种模式，内核态和用户态。软件中最基础的是操作系统，它运行在**内核态**。在这个模式中，操作系统具有对所有硬件的访问权，可以执行机器能够执行的任何指令。
软件的其余部分运行在**用户态**。

(1) 操作系统的任务是创建好的抽象，并实现和管理它所创建的抽象对象，也就是隐藏硬件，呈现一个好的抽象。
(2) 操作系统还负责对处理器，存储器以及其他I/O接口的资源分配。包括两种方式实现**多路复用**， 时间上复用和空间上复用。
总的来说：

>操作系统是一种软件，它可以接触到所有的硬件，在用户软件和硬件之间搭建桥梁。主要负责的功能有提供调度硬件的接口，免去了低层机器语言复杂的接口设置，更抽象，负责资源分配和管理，包括内存，文件和设备的管理．



#### 操作系统硬件介绍

##### (1) 处理器

了解处理器(processor)，处理器以Fetch-Decode-Execute来处理命令，并且有专门的单元做这些操作．

**(2) 内存**

了解内存(Memory)，内存空间大的，读取速度就慢，空间小的，速度就快．最快是寄存器(register)，但是可存放的内容＜１K.依次有寄存器，缓存(cache), Main memory（主存），disk（硬盘）.其中主存也叫做RAM(Random Access Memory);

**关于内存分配中的栈和堆：**
栈是函数调用的时候会自主分配的空间；堆是需要手动去申请的。

**C++中的内存分配：**
栈中分配局部变量空间，堆区是向上增长的用于分配程序员申请的内存空间。另外还有静态区是分配静态变量，全局变量空间的；只读区是分配常量和程序代码空间的；以及其他一些分区。
栈在高位，向下增长；堆在低位，向上增长；
![avatar](https://img-blog.csdn.net/20180226135414709)

```cpp
int a = 0; //全局初始化区 
char *p1; //全局未初始化区 
main() 
{ 
    int b; //栈 
    char s[] = "abc"; //栈 
    char *p2; //栈 
    char *p3 = "123456"; //123456\0在常量区，p3在栈上。 
    static int c =0； //全局（静态）初始化区 
    p1 = (char *)malloc(10); //堆 
    p2 = (char *)malloc(20);  //堆
```

>系统调用：
现代的操作系统中，用户的权限是有限的，它不能随意的访问系统中的资源．操作系统屏蔽了用户直接访问硬件的能力，　如果我们想要使用硬件功能，就必须借助操作系统的帮助．
>我们使用的c语言里面的printf函数，其真实调用的是系统调用接口中的write，操作系统提供的这一系列接口就是系统调用接口。

>总结来说，系统调用就是用户进程申请操作系统的帮助，让操作系统帮其完成某项工作，也就相当于用户进程调用了操作系统的功能。

C++的那些接口或者Linux的syscall其实是一个间接的系统调用，它是一个库函数，不是操作系统直接提供的。

###进程与线程
####１.进程
狭义定义：　进程就是一段程序的执行过程

广义定义：　进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动．它是操作系统**动态执行**的基本单元，　在传统的操作系统中，　**进程既是基本的分配单元，也是基本的执行单元．**
(1) 进程是一个实体．每一个进程都有它自己的地址空间．一般情况下，包括文本区域，　数据区域，和堆栈．
文本区域：　存放处理器执行的代码
数据区域：存储变量和执行期间使用的动态分配的内存．
堆栈区域：活动过程调用的指令和本地变量．

(2) 进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程.

>守护进程：
在后台中接收请求，请求到达时就被唤醒来服务该请求的进程。

>孤儿进程：
如果父进程先退出,子进程还没退出那么子进程将被 托孤给init进程,这是子进程的父进程就是init进程(1号进程)。

>僵尸进程：
如果我们了解过linux进程状态及转换关系,我们应该知道进程这么多状态中有一种状态是僵死状态,就是进程终止后进入僵死状态(zombie),等待告知父进程自己终止,后才能完全消失.但是如果一个进程已经终止了,但是其父进程还没有获取其状态,那么这个进程就称之为僵尸进程.僵尸进程还会消耗一定的系统资源,并且还保留一些概要信息供父进程查询子进程的状态可以提供父进程想要的信息.一旦父进程得到想要的信息,僵尸进程就会结束.

fork:
新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。
* 调用了fork后， 这两个进程拥有相同的存储映像， 同样的环境字符串和同样的打开文件。
* 子进程接着执行execve或者一个类似的系统调用，以修改其存储映像，并运行一个新的程序。父进程和子进程拥有各自不同的系统空间。

进程的状态：
(1) 运行态（此时实际占用CPU)
(2) 就绪态(可运行，但是因为其他进程正在运行而暂时停止)
(3)阻塞态 (除非某种外部事件发生，否则进程不能运行)

状态之间是可以互相转换的：
运行和就绪的转换： 进程调度引起的；
阻塞变就绪：比如输入到达时；
运行变阻塞：磁盘中断；

进程表：
关系着进程是如何实现的，每个进程维护一个进程表，包含了进程状态的重要信息，包括堆栈指针，内存分配状况，所打开文件的状态，以及一些由运行状态转换到阻塞状态时必须保存的信息，从而保证该进程能够再次启动。

CPU利用率：
假设一个进程等待I/O的时间与其停留在CPU中的时间的比为p；
那么有n个进程，所有的进程都在等待I/O的概率是p^n；
```cpp
CPU利用率 = 1 - p^n;
```
>一个进程切换的过程：
(1) 硬件压入堆栈

####2.线程
通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为**分配资源**的基本单位，而把线程作为**独立运行和独立调度**的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。

(1)并行实体共享同一个地址空间和所有可用数据的能力；
(2)线程比进程更轻量级，所以它们比进程更容易被创建和销毁，在需要大量的创建和快速修改时，会倾向于用多线程；
(3)主要还是像刚刚讨论I/O时候的用处， 在存在大量计算和I/O处理，拥有多个线程允许这些活动彼此进行重叠进行，从而会加快程序执行的速度。

高速缓存：
是为了避免重新到磁盘调用引起的I/O时间， 把大量访问的页面集合保存在内存中。
分派程序挑选一个空转的（就是被阻塞的）工作线程， 检查它要求的页面是否在高速缓存中， 如果没有， 从磁盘读入，并且阻塞到直到磁盘完成读入；

总的来说，就是操作系统给进程分配资源，为了能够加快程序执行速度，进程可以拥有若干个线程，它们共享相同的进程资源，能访问同一片地址空间，这部分就属于进程的内容，包括：**地址空间，全局变量，打开的文件，即将发生的警报，信号与信号处理系统，账户信息等。**
其余的属于每个线程自己的内容，**程序计数器，寄存器，堆栈，状态**就是为了这些线程能够独立的活动并且阻塞时能够重新回到就绪状态。这些信息和进程类似，存在线程表里
线程和进程非常相似，包括线程也可以调用函数创建新的线程，一个线程也可以等待一个特定的线程退出，这个线程会阻塞直到那个线程退出。
看起来CPU的并行，其实就是通过切换进程和线程来实现的。


#####线程的实现：
有两种主要的方法实现， 在用户空间中和在内核中。
(1)把线程放在用户空间中实现，内核（内核中唯一的软件也就是操作系统）对线程一无所知，按照单线程进程管理。
优点：可以在不支持多线程的操作系统上实现多线程；
它允许每个进程有自己定义的调度算法。

>线程和进程有一个关键的差别，就是线程调度为什么快捷；线程的切换可以在几条指令内完成，只需要堆栈指针和程序计数器一被切换，新的线程就自动投入运行；保存线程状态和调度程序都只是本地过程， 不需要陷阱，不需要上下文切换，不需要对内存高速缓存进行刷新。

存在的问题：
(1)如何实现阻塞系统调用，允许每个线程能够实现阻塞调用但是又不想影响被阻塞的线程影响别的线程（因为内核不知道线程的存在，一旦有一个线程阻塞，通常会把整个进程阻塞直到磁盘I/O完成）
有一个系统调用select可以允许调用者预先通知预期的read调用是否会阻塞。如果会被阻塞，那就不进行直到下次就检查read调用是否安全，来避免造成整个进程的阻塞；

(2)在一个进程内，没有轮转调度算法，所以如果一个线程开始运行，除非它放弃CPU，不然别的线程就没有机会运行。

内核线程实现：
这时候内核意识到线程的存在，并且可以当作类似“进程”来对待，所有能够阻塞线程的调用都以系统调用的形式实现；当一个线程阻塞时，可以运行同一个进程的另外一个线程或者其他进程的线程；
内核中创建和销毁线程的代价较大；所以某些系统当某个线程被撤销时，就把它标志为不可运行的，但是并不会实际销毁，创建某个新的线程时，就重新启用某个旧线程，这样子的**回收**机制；

####进程间通信
* 竞争条件:指的是两个或者多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序。称为竞争条件。
* 临界区：
阻止多个进程同时读写共享区域的办法就是互斥；使得两个进程不可能同时处于临界区中；
临界区指的是 对共享内存进行访问的 程序片段；

* 忙等待
自旋锁；
最简单实现互斥的方法，首先想到是屏蔽中断，在每个进程进入临界区后立即屏蔽中断，出去时重新打开；这样子CPU就不会切换进程；但是这个方案并不好，将屏蔽中断的权力交给用户进程，万一进程不恢复中断，那么系统都瘫痪了；
锁变量，设置一个变量，如果一个进程想进到临界区，首先测试这把锁，如果是0则进入，就把锁设置为1并进入临界区；如果是1就等待锁变为0；这样一样不能躲过CPU切换时带来的问题，万一第一个进程检查发现是0，还没来得及写1的时候，另一个进程切换过来发现也是0，进去临界区读写并且锁为1，切换回第一个进程的时候，它以为锁为0，接着执行，这时就有两个进程进入了临界区；

自旋锁：检查锁变量，发现为0，则进入临界区，另外一个也发现其为0，在一个等待循环中不停的测试锁变量，看其值何时为1.连续测试一个变量直到其值改变为止，称为**忙等待**。

只有有理由认为等待时间非常短的时候，采用忙等待，忙等待用的锁称为自旋锁；在一个进程比另一个进程慢了很多的情况下，轮流进入临界区并不是一个好主意。

```cpp
while(true){
    while(turn!=0){
        critical_region();
        turn=1;
        noncritical_region();
    }
}
//对于进程0

while(true){
    while(turn!=1){
        critical_region();
        turn = 0;
        noncritical_region();
    }
}
```
* 睡眠与唤醒
忙等待情况下，当一个进程想进入临界区，先检查是否允许进入，若不允许，该进程将原地等待，直到允许为止；
这不但浪费了CPU时间，还可能会造成优先级反转问题；

生产者和消费者问题：
被称作有界缓冲区问题， 两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，将信息放入缓冲区，另一个是消费者， 从缓存区中取出信息；
问题在于缓存区满时的状况，此时生产者向其中放入一个新的数据项，可以让生产者休眠，待消费者取出数据后再唤醒他；
同样，当消费者想取数据，发现缓存区为空时，消费者就睡眠，直到生产者产生一些顺序把它唤醒；
**条件竞争在于缓存区的数目指数count；**

信号量：
两种操作；down或者up；对一信号量执行down操作，则是检查其值是否大于0，若该值大于0，则将值-1；若该值为0，则进程将休眠，而且此时down并未结束；
信号量的原子操作是通过屏蔽中断来实现的。测试信号量，更新信号量，需要时使某个进程休眠。由于这些动作只需要几条指令，所以屏蔽中断不会带来什么副作用；

```cpp
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void product(void){
    int item;
    while(true){
        item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}
void consumer(void){
    int item;
    while(true){
        down(&full);
        down(&mutex);
        item = remove_item();
        up(&mutex);
        up(&empty);
        consume_item(item);
    }
}
```
down两个信号量的顺序，两个次序不能更改否则会造成死锁；
如果先down了mutex， 此时mutex=0,缓存区又满了，无法down到empty， 那么生产者将阻塞，等待消费者来消费；
问题是消费者试图down mutex，发现mutex=0，就一直无法进入缓存区，也进入了阻塞，两个进程将永远的阻塞下去；

###存储管理


###文件系统

###输入/输出

###死锁

###多媒体操作系统

###多处理机系统

###安全

###关于Linux 实例

###关于Windows实例

