[TOC]



## 进程（process）和线程（Thread）

### 一. 进程

严格地说，**在某一个瞬间，CPU只能运行一个进程。**但CPU可以由一个进程快速切换到另一个进程（**伪并行**），这种快速的切换称为**多道程序设计**。

> **多处理器系统**是真正的硬件并行，它有两个或多个CPU共享一个物理内存。

 

#### **进程的定义**

 一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干个进程共享，它使用某种调度算法决定何时停止一个程序的工作，并转而为另一个进程提供服务。

> 注意：如果一个程序运行了两遍，则算作两个进程。



与每个进程相关的是**进程的地址空间（address space）**，这是从某个最小值的存储位置（通常是零）到某个最大值存储位置的列表。在这个地址空间中，进程可以进行读写。该地址空间中存放有**可执行程序（代码）、程序的数据及程序的堆栈**。**与每个进程相关的还有资源集**，通常包括寄存器（含有程序计数器和堆栈指针）、打开文件的清单、相关进程清单、以及运行该程序所需要的所有其他信息。



**一个挂起的进程包括：**进程的地址空间，往往称作磁芯映像（core image），以及对应的进程表项，其中包括寄存器以及稍后重启该进程所需要的许多其他信息。





**守护进程（daemon processes）：**停留在后台处理的进程



#### 创建进程

在UNIX系统中，只有一个系统调用可以用来创建新进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用fork后，这两个进程（父进程和子进程）拥有相同的存储映像、同样的环境字符串和同样的打开文件。通常，子程序接着执行`execve` 或一个类似的系统调用，以修改其存储映像并运行一个新的程序。

**（在进程创建之后，父进程和子进程有各自不同的地址空间。）**

<img src="https://upload-images.jianshu.io/upload_images/4912589-ed5ebac001c4bd3c.gif?imageMogr2/auto-orient/strip|imageView2/2/w/557/format/webp" alt="img" style="zoom: 80%;" />

> **`fork()` 函数详解：**https://www.jianshu.com/p/484af1700176 

> **存储映像：**是指和被加载的磁盘文件相对应的一块内存区域。当程序没有被运行或者加载的时候，它是以文件的形式存放在硬盘上的。当它被加载的时候，系统会自动从内存中划分出一段区域，用来将这个磁盘上的文件映射到内存相应的位置上。此时这块内存中的数据就是磁盘文件的一个拷贝。这段内存空间是和刚才的磁盘文件相关联的，因此对这段内存进行数据修改，也相当于在磁盘文件上做了修改。



#### **进程的终止**

- 正常退出（自愿的）
- 出错退出（自愿的）
- 严重错误（非自愿）
- 被其他进程杀死（非自愿）



#### **进程的层次结构**

某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。在UNIX中，进程和它的所有子女以及后裔共同组成一个进程组。

- Windows中没有进程层次的概念，所有进程都是地位相同的。惟一类似于进程层次的暗示是在创建进程的时候，父进程得到一个特别的令牌（句柄），该句柄可以用来控制子进程。但是它有权把这个令牌传给某个其他进程，这样就不存在进程层次了。



#### 进程的状态

<img src="https://tse3-mm.cn.bing.net/th?id=OIP.16LTOLCgy2OUvJ1ab-VYEgHaEu&amp;w=292&amp;h=180&amp;c=7&amp;o=5&amp;pid=1.7" alt="进程的状态 的图像结果" style="zoom:150%;" />

- 运行态：该时刻进程实际占用GPU
- 就绪态：可运行，但因为其他进程正在运行而暂时停止，例如发生进程调度。
- 阻塞态：除非某种外部事件发生，否则进程不能运行，例如等待输入



#### 进程的实现

为了实现进程模型，操作系统维护着一张表格（一个结构数组），即**进程表（process table）**，每个进程占用一个进程表项。（有时候这些表项为**进程控制块**）

进程表表项<img src="https://images2018.cnblogs.com/blog/1226410/201805/1226410-20180515110204310-246199192.png" alt="查看源图像" style="zoom:80%;" />





### 二. 线程

线程是CPU上被调度执行的实体。



多线程其实也是CPU在线程之间快速切换，制造线程并行运行的假象。



进程拥有一个执行的线程，通常简称为线程（thread）。在线程中有：

- 程序计数器用来记录接着要执行哪一条命令
- 寄存器用来保存线程当前的工作变量
- 栈用来记录执行历史，其中每一帧保存一个已调用但是还没有从中返回的过程

**线程之间共享地址空间。**





<img src="https://tse4-mm.cn.bing.net/th?id=OIP.6eKRmDRuEh5OJLHDxY5hmAHaCN&amp;w=244&amp;h=89&amp;c=7&amp;o=5&amp;pid=1.7" alt="操作系统  线程中的内容 的图像结果" style="zoom:150%;" />





#### 面试题：进程和线程的区别

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间；在保护模式下，一个进程的崩溃不会影响其他进程。线程只是一个进程中的不同执行路径；线程有自己的堆栈和局部变量，但是它们没有独立的地址空间；一个线程的死掉等于整个进程的死掉，所以多进程程序要比多线程程序健壮。但是进程切换时资源消耗比较大、效率较低。而且对于一些要求同时进行并且又要共享某些变量的并发操作，只能使用线程。

> 参考博客：https://blog.csdn.net/mxsgoden/article/details/8821936







### 三. 进程间通信（Inter Process Communication, IPC）

#### 1. 竞争条件（race condition）

两个或者多个进程读写某些共享数据，最后的结果依赖于进程运行的精确时序。



#### 2. 临界区（critical region）

共享文件以及共享自愿可能会引发一些错误，要避免这种错误，我们需要的是互斥（mutual exclusion），即以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。

- 任何两个进程不能同时处于其临界区；
- 不应对CPU的速度和数量做任何假设；
- 临界区外运行的进程不得阻塞其他进程；
- 不得使进程无限期等待进入临界区；



<img src="/media/b3-542/0C3D65931B1CCAB5/TianfeiYu/Typora/imgs/操作系统/critical_region.jpg" alt="critical_region" style="zoom:50%;" />



##### 1) 屏蔽中断

屏蔽中断是指在每个进程刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。这样，在屏蔽中断之后CPU将不会被切换到其他进程。

- 缺点：对于单核系统，整个系统可能会因此终止。




##### 2) 锁变量

设置一个共享（锁）变量，其初始值为0。当一个进程想进入其临界区时，它首先测试这把锁。如果该锁的值为0，则该进程将其设置为1并进入临界区。若这把锁的值为1，则该进程将等待直到其值变为0.

- 缺点：假设一个进程读出锁变量的值并发现它为0，而恰好在它将其值设置为1之前，另一个进程被调度运行，将该锁变量设置为1。




##### 3) 严格轮换法

整型变量turn，初始值为0，用于记录轮到哪个进程进入临界区，并检查或更新共享内存。开始时，进程0检查turn，发现其值为0，于是进入临界区。进程1也发现其值为0，所以在一个等待循环中不停地测试turn，看其值何时变为1。

- 连续测试一个变量直到某个值出现为止，称为**忙等待（busy waiting）**。

  > 只有在理由认为等待时间是非常短的情形下，才使用忙等待。

- 用于忙等待的锁，称为**自旋锁（spin lock）**。

```c++
#process 0
while(true){
    while(turn != 0);
    critical_region();
    turn = 1;
    noncritical_region();
}

#process 1
while(true){
    while(turn != 1);
    critical_region();
    turn = 0;
    noncritical_region();
}
```

- 缺点：在一个进程比另一个进程慢很多的情况下，轮流进入临界区不是一个好方法。




##### 4) Peterson算法

```c++
#define FALSE 0
#define TRUE 1
#define N

int turn;
int interested[N];

void enter_region(int process){								//进程号是0或1
	int other;												
	
	other = 1 - process;
	interested[process] = TRUE;								//表示所感兴趣的
	turn = process;											//设置标志
	while(turn == process && interested[other] == TRUE);
}

void leave_region(int process){
    interested[process] = FALSE;
}
```

- 相比`严格轮换` ，Peterson算法不要求两个进程轮流进入临界区
- 当两个进程几乎同时进入临界区时，它们都会将自己的进程号存入turn，但只有后被保存进去的进程号才有效，前一个因被重写而丢失。假设进程1是后存入的，则turn为1,。当两个进程都运行到while语句时，进程0将循环0次并进入临界区，而进程1将不停地循环且不能进入临界区，直到进程0退出临界区为止。



##### 5) TSL（Test and Set Lock）指令

它将一个内存字`lock` 读到寄存器`RX` 中，然后在内存地址上存一个非零值。TSL 指令需要硬件的支持，以保证读字和写字操作是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字，执行TSL 指令的CPU 将锁住内存总线，以禁止其他CPU在本指令结束之前访问内存。

```
enter region:
	TSL REGISTER, LOCK		|复制锁到寄存器并将锁设为1
	CMP REGISTER, #0		|锁是零吗？
	JNE enter_region		|若不是零，说明锁已被设置，所以循环
	RET						|返回调用者，进入临界区
	

leave_region:
	MOVE LOCK, #0			|在锁中存入0
	RET						|返回调用者
```







#### 3. 睡眠与唤醒（sleep & weak up）

- Peterson解法和TSL解法都正确，但是它们都有忙等待的缺点，它会存在浪费CPU时间等问题
- sleep是一个将引起调用进程阻塞的系统调用，即被挂起，直到另外一个进程将其唤醒
- wakeup调用有一个参数，即要被唤醒的进程

```c++
#define N 100
int count = 0;

void producer(void){
	int item;
	
	while(TRUE){
		item = produce_item();
		if(count == N) sleep();
		insert_item(item);
		count += 1;
		if(count == 1) wakeup(consumer);
	}
}

void consumer(void){
	int item;
	while(TRUE){
		if(count == 0) sleep();
		item = remove_item();					//从缓冲区中取出一个数据项
		count -= 1;
		if(count == N - 1) wakeup(producer);
		consume_item(item);						//打印数据项
	}
}
```

缺点：对`count` 变量的访问未加限制，所以发给一个尚未睡眠的进程的wakeup信号丢失。





#### 4. 信号量（semaphore）

一个信号量的取值可以为0（表示没有保存下来的唤醒操作）或者正值（表示有一个或多个唤醒操作）。信号量包括两种操作：

- `down` 操作，则是检查其值是否大于0。如果signal大于0，那么把它-1，进程继续执行；如果signal为0，那么执行`down` 操作的进程将会被阻塞，从而变为阻塞态，添加到因为signal信号而阻塞的进程队列中。
- `up` 操作对信号量的值增1。如果signal本来就大于0，那么执行+1；如果有进程在该信号量上被阻塞，那么从队列中根据某种策略选择一个进程唤醒。如果多个进程在该信号量上阻塞，那么`up` 操作后，signal仍然可能为负数。
- `down` 和`up` 操作中的检查数值、修改变量以及可能发生的睡眠操作均作为一个单一的、不可分的原子操作完成。

```c++
#define N 100
typedef int semaphore;
semaphore mute = 1;
semaphore empty = N;
semaphore full = 0;

void producer(void){
	int item;
	
	while(TRUE){
		item = produce_item();		//产生放在缓冲区中的一些数据
		down(&empty);				//将空槽数目减1
		down(&mutex);				//进入临界区
		insert_item(item);			//将新数据项放到缓冲区中
		up(&mutex);					//离开临界区
		up(&full);					//将满槽的数目加1
	}
}

void consumer(void){
	int item;
	while(TRUE){
		down(&full);
		down(&mutex);
		item = remove_item();
		up(&mutex);
		up(&empty);
		consume_item(item);
	}
}
```



#### 5. 互斥量（mutex）

互斥量其实可以理解为一个简化的信号量，它只有两种状态：0和1。互斥锁是用来解决**进程（线程）互斥**问题的。所谓进程互斥，就是两个进程实际上是一种互斥的关系，两者不能同时访问共享资源。

互斥量和信号量原理比较类似，一旦一个线程获得了锁，那么其它线程就无法访问共享资源，从而被阻塞，直到该线程交还出了锁的所有权，另外一个线程才能获得锁。





##### 互斥量和临界区的区别

- `mutex` 没有忙等待，当其获取锁失败后，它调用`thread_yield` 将CPU放弃给另一个线程。在该线程下次运行时，它再一次对锁进行测试。

- 临界区其实是定义的一个函数或一段代码，当多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。互斥量是为协调共同对一个共享资源的单独访问而设计的。



##### 条件变量

- 条件变量是另外一种同步机制，可以用于线程和管程中的进程互斥。通常与互斥量一起使用。

- 条件变量允许线程由于一些暂时没有达到的条件而阻塞。通常，等待另一个线程完成该线程所需要的条件。条件达到时，另外一个线程发送一个信号，唤醒该线程。





#### 6. 管程（Monitor）

一个管程是一个由过程、变量及数据结构等组成的一个集合，它们组成一个特殊的模块或者软件包。

- 任一时刻管程中只能有一个活跃进程
- 进入管程的互斥由编译器负责，通常的做法是用一个互斥量或二元信号



#### 7. 信息传递（message passing）

进程间通信的方法使用两条原语`send` 和 `receive` 

```c++
send(destination, &message);
receive(source, &message);
```

前者调用向一个给定的目标发送一条消息，后一个调用从给定的源（或任意的源）接收一条消息。如果没有消息可用，则接收者可能被阻塞，直到一条消息的送达，或者，带着一个错误代码立即返回。

```c++
#define N 100

void producer(void){
	int item;
	message m;
	while(TRUE){
		item = produce_item();
		receive(consumer, &m);
		build_message(&m, item);
		send(consumer, &m);
	}
}

void consumer(void){
	int item, i;
	message m;
	
	for(i = 0; i < N; i++) send(producer, &m);
	while(TRUE){
		receive(producer, &m);
		item = extract_item(&m);
		send(producer, &m);
		consume_item(item);
	}
}
```



#### 8. 屏障（barrier）

屏障是用于进程组而不是双进程的生产者—消费者类型的。在有些应用中划分了若干阶段，并且规定，除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段。

可以通过在每个阶段的结尾安置屏障来实现这种行为。当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都达到屏障为止。





### 四. 调度（scheduler）

当计算机系统是多道程序设计系统时，通常就会有多个进程或线程同时竞争CPU，所以需要进程的调度。



#### 何时调度

- 在创建一个新进程后，需要决定是运行父进程还是子进程
- 在一个进程退出时必须做出调度决策，需要从就绪进程集中选择另外某个进程
- 当一个进程阻塞在I/O和信号量上或由于其他原因阻塞时，必须选择另一个进程运行
- 在一个I/O中断发生时，说明该设备已经完成了工作，某些被阻塞的等待该I/O的进程就可以称为可运行的就绪进程



#### 调度算法分类

**非抢占式调度算法：**挑选一个进程，然后让该进程运行直到被阻塞（阻塞在I/O上或等待另一个进程）。或者直到该进程自动释放CPU；

**抢占式调度算法：**挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行。





##### 1. 批处理系统中的调度

- **先来先服务（first-come first-serverd）**
  - 属于非抢占式调度，进程按照它们请求CPU的顺序使用CPU，并允许运行它所期望的时间。
  - 优点：易于理解并且便于在程序中运行
  - 缺点：如果该进程是I/O密集型，则对CPU的资源浪费比较大
- **最短作业优先（shortest job first）**
  - 优先使用作业时间短的进程
- **最短剩余时间优先（shortest remaining time first）**
  - 抢占式版本的最短作业优先





##### 2. 交互式系统中的调度

- **轮转调度（round robin）**
  -  每个进程被分配一个时间段，称为时间片（quantum），即允许该进程在该时间段中允许。如果在时间片结束时该进程还在运行，则将剥夺CPU并分配给另一个进程。
- **优先级调度**
  - 赋予不同进程不同的优先级，允许优先级最高的可运行进程先运行；
  - 为防止高优先级进程无休止地运行下去，调度程序可以在每个时钟滴答（即每个时钟中断）降低当前进程的优先级。
- **多级队列**
  - 属于最高优先级类的进程运行一个时间片，属于次高级类的进程运行2个时间片，再次一级运行4个时间片，以此类推。
  - 优点：提高CPU密集型进程的运行效率，可以减少它们需要的交换次数
- **最短进程优先**
  - 根据进程过去的行为推测它可能的运行时间，并执行估计运行时间最短的那个
- **保证调度**
  - 系统跟踪各个进程自创建以来已使用了多少CPU时间，然后计算各个进程应获得的CPU时间，即自创建以来的时间除以总进程数
- **彩票调度**
  - 向进程提供各种系统资源（如CPU时间）的彩票，一旦需要做出一项调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源



##### 3. 实时系统中的调度

pass









































